# inlined-copy 開発ガイド

このドキュメントは、inlined-copy VS Code拡張機能の開発者向けに包括的な技術情報を提供します。

## 技術スタック

1. Node.js (v18以上)
   - VS Code拡張機能の実行環境
2. pnpm
   - 依存関係管理ツール
   - 主要コマンド: `pnpm install`, `pnpm update`
3. TypeScript
   - 拡張機能の実装言語
   - コンパイル: `pnpm tsc -p ./`
4. ESLint + Prettier
   - コード品質とスタイル統一ツール
   - コマンド: `pnpm run lint`, `pnpm run lint:fix`
5. Vitest
   - テストフレームワーク
   - コマンド: `pnpm test`, `pnpm run test:coverage`
6. VS Code Extension API
   - 拡張機能開発フレームワーク
   - デバッグ起動: F5キー

## コード品質とスタイルガイドライン

### コードスタイルとリントルール

ESLintとPrettierを使用してコード品質とスタイルをチェックします。すべてのコードは、コミットする前にESLintエラーがなく、Prettierフォーマットルールに準拠している必要があります。ESLintは主にバグにつながる可能性のあるコードや非推奨の構文を検出し、Prettierはコードフォーマット（空白、改行など）を強制します。開発者は、これらのツールからの警告とエラーを定期的にチェックする必要があります。

### TypeScript命名規則

このプロジェクトでは、コードベース全体で一貫した命名を維持するために `@typescript-eslint/naming-convention` ルールに従います：

#### 変数と定数
| ルール | 例 | 備考 |
|------|---------|-------|
| **通常の変数** | `camelCase` | `const filePath = "/path/to/file";` |
| **定数（不変）** | `UPPER_CASE` | `const MAX_RETRY_COUNT = 3;` |
| **未使用変数** | `_prefixed` | `const _unusedVariable = "not used";` (ESLintの未使用変数エラーを回避) |

**未使用変数 (_unusedVariable)**
- 一般的に、未使用の変数はコードから削除すべきです。
- ただし、開発中の一時的に未使用の変数や、特定のESLintルール(@typescript-eslint/no-unused-vars)を回避するために `_` プレフィックスが許可されています。
- `_` プレフィックスは、「これは一時的に未使用の変数です」と他の開発者に明示的に示し、コードが最終化されたときに理想的には削除されるべきです。

#### 関数
| ルール | 例 | 備考 |
|------|---------|-------|
| **通常の関数** | `camelCase` | `function getFilePath() {}` |
| **プライベートメソッド** | `_prefixed` | `private _processFile() {}` (JS互換性のために許可) |

#### 型とクラス
| ルール | 例 | 備考 |
|------|---------|-------|
| **クラスとインターフェース** | `PascalCase` | `class FileProcessor {}` / `interface FileOptions {}` |
| **型エイリアス** | `PascalCase` | `type FileMap = Map<string, string>;` |

### ESLint設定と使用法

このプロジェクトでは、コード品質を維持するために以下のESLintルールを適用しています：

#### 1. `@typescript-eslint/naming-convention` の適用
ESLint設定（`.eslintrc.json`）で命名規則を明確に定義しています：

```json
{
  "rules": {
    "@typescript-eslint/naming-convention": [
      "error",
      {
        "selector": "variable",
        "format": ["camelCase", "UPPER_CASE"],
        "leadingUnderscore": "allow"
      },
      {
        "selector": "parameter",
        "format": ["camelCase"],
        "leadingUnderscore": "allow"
      },
      {
        "selector": "property",
        "format": ["camelCase", "UPPER_CASE"],
        "leadingUnderscore": "allow"
      },
      {
        "selector": "typeLike",
        "format": ["PascalCase"]
      }
    ]
  }
}
```

- `_` プレフィックス付きの未使用変数を許可
- 定数（`UPPER_CASE`）に厳格なルールを適用
- 型の命名を統一（`PascalCase`）

#### 2. `@typescript-eslint/no-unused-vars` の調整
ESLint設定では、未使用変数エラーを回避するために `_` プレフィックス付きの変数を許可しています：

```json
{
  "rules": {
    "@typescript-eslint/no-unused-vars": [
      "warn",
      { "argsIgnorePattern": "^_", "varsIgnorePattern": "^_" }
    ]
  }
}
```

##### 使用ルール
- ✅ `_unusedVariable` はESLint警告を回避します
- ❌ `unusedVariable` は未使用の場合に警告をトリガーします
- ✅ `function (_param: string) {}` は未使用パラメータの警告をトリガーしません

##### _ プレフィックスが推奨されるケース：

✅ **意図的に未使用の関数パラメータ：**
- `_filePath` は将来的に使用される可能性がありますが、現在は未使用のため、`_` プレフィックスが付けられています
- `_` プレフィックスを追加することで、ESLint @typescript-eslint/no-unused-vars ルールを回避しながら、「意図的に未使用」であることを示します

✅ **デバッグ中の一時変数：**
- `_debugData` をデバッグ情報の一時変数として使用し、最終的に削除される予定のもの

❌ **以下のケースでは _ プレフィックスを使用しないでください：**
- **プレフィックスを付ける代わりに削除すべき変数**
  - 完全に不要な `_unusedValue` はプレフィックスを付けるのではなく削除すべきです
- **プライベートにすべきクラスプロパティ**
  - `_id` のようなプロパティは、アンダースコア規則に依存するのではなく `private` 修飾子を使用するべきです

### 自動フォーマット

プロジェクトはPrettierのデフォルトスタイルガイド（必要に応じてチーム固有の設定を含む）を採用しています。**ルールとして、手動でコードをフォーマットしないでください**；エディタのフォーマッタ機能または提供されたスクリプト（以下参照）を使用して自動フォーマットを行ってください。

- 保存時の自動フォーマットが有効になっていれば、開発中にスタイルが適用されます。そうでない場合は、`pnpm run prettier:fix` を使用してすべてのファイルをフォーマットできます。
- Prettierフォーマットから除外するファイルがある場合は、`.prettierignore` で指定してください。

### ESLintルール

ESLint設定は `eslint:recommended` と `@typescript-eslint/recommended` に基づいており、基本的なベストプラクティスに従っています。重要なルールには以下が含まれます：

- 未使用変数の禁止（no-unused-vars）
- 暗黙的な any の禁止（@typescript-eslint/no-explicit-any など、strict モードで強制）
- コンソール出力とデバッグコードの削除（必要に応じてルールを追加）

Prettierと競合するルールは無効化されています。詳細なルールセットについては、プロジェクトルートの `.eslintrc.json` を参照してください。

### TypeScript型チェック

型エラーはTypeScriptコンパイル（`tsc --noEmit`）を使用してビルド前に検出されます。開発者はエディタに表示される型エラーに注意し、型の不整合を未解決のままにしないようにしてください。VS Code拡張機能を開発する際は、VS Code API型定義（vscode.d.ts）を正しくインポートし、型エラーがないことを確認してください。

### プリコミットフック

Gitフックはコミット時に自動的にlint-staged、型チェック、テストを実行するように設定されています。**コード検証はコミット時に自動的に実行され、問題がある場合はコミットがブロックされます。**

- **lint-staged**: コミット用にステージングされているファイルのみをチェックおよびフォーマットし、コードベース全体を処理しないことでパフォーマンスを向上させます。コミットが完了する前に、フォーマットされたファイルを自動的に再ステージングします。
- **型チェック**: ステージングされているかどうかに関わらず、すべてのTypeScriptコードが型安全であることを確認します。
- **テスト**: コミットを許可する前にすべてのテストがパスすることを確認します。

プリコミットワークフローに関する重要な注意事項：
- フックが失敗した場合、エラーの詳細がターミナルに表示されます。指示に従って問題を修正し、`git add` と `git commit` を再度実行してください（修正後に新しいコミットを作成する必要があります）。
- フック処理を一時的にスキップする必要がある場合（緊急コミットなど）、環境変数を設定してオフにできます：`HUSKY=0 git commit ...`。ただし、ルールとして、コミットする前に品質チェックに合格するという習慣を維持してください。
- lint-stagedはフォーマット後にファイルを自動的に再ステージングするため、コミットされる内容は最初にステージングしたものと若干異なる場合があります（ただし、適切にフォーマットされています）。
- `pretest` スクリプトは二重のリント操作を避けるためにテスト前のリントを実行しなくなりました。lint-stagedがコミット中にこれを処理するためです。

### 推奨エディタ設定

VS Codeを使用している場合、ESLintとPrettier拡張機能をインストールし、保存時に自動的にフォーマットおよび修正するように設定することをお勧めします。推奨設定については、プロジェクトの `.vscode/extensions.json` と `.vscode/settings.json` を確認してください。これにより、開発中のシームレスな静的解析とコードフォーマットが可能になります。

### コマンドリスト

開発者向けの便利なスクリプトとその目的のリストは以下の通りです：

- `pnpm run lint`: ESLint静的解析チェックを実行
- `pnpm run lint:fix`: ESLint自動修正を実行
- `pnpm run prettier:check`: Prettierフォーマット検証を実行
- `pnpm run prettier:fix`: Prettier自動フォーマットを実行
- `pnpm run typecheck`: TypeScript型チェックのみを実行
- `pnpm run test`: テストを実行（現在Vitestを使用）

これらはCIでも使用される可能性があるため、プッシュする前にローカルで動作するか確認してください。

## セットアップ

1. pnpmをインストール
2. `pnpm install` を実行
3. F5キーを押してデバッグを起動

## ローカルテスト

```
pnpm install    # 初回のみ
pnpm run compile
code --extensionDevelopmentPath=${PWD}
code . --extensionDevelopmentPath=$PWD
```

Ctrl+Shift+P（Mac: Cmd+Shift+P）でコマンドパレットを開き、「Inlined Copy: Copy Inline」を選択します

## ビルドとパッケージング

拡張機能をビルドするには：

```
pnpm run compile
```

拡張機能をVSIXファイルとしてパッケージ化するには：

```
pnpm install -g @vscode/vsce
vsce package
```

## ロギング

### LogManagerの概要

拡張機能には、コードベース全体で一貫したログ機能を提供する集中化された `LogManager` クラスが含まれています。主な利点は以下の通りです：

- 拡張機能のすべてのコンポーネントに対する**統一されたログインターフェース**
- 詳細度を制御する**設定可能なログレベル**
- 開発とトラブルシューティングのための**デバッグモード**
- VS Codeの**出力チャンネル統合**による永続的なログ

### LogManagerの使用

`LogManager` は、異なる重要度レベルを持つ4つの主要なロギングメソッドを提供します：

```typescript
// デバッグメッセージ（デバッグログレベルでのみ表示）
LogManager.debug('ファイル参照を処理中: ' + filePath);

// 情報メッセージ
LogManager.info('ファイルが正常に展開されました', true); // 2番目のパラメータはユーザーにメッセージを表示

// 警告メッセージ（デフォルトでユーザーに表示）
LogManager.warn('重複参照が検出されました: ' + fileName);

// エラーメッセージ（デフォルトでユーザーに表示）
LogManager.error('ファイルパスの解決に失敗しました: ' + filePath);
```

各メソッドは以下を受け入れます：

1. メッセージ文字列
2. メッセージをユーザーに表示するかどうかを制御するオプションのブール値パラメータ

### ロギングの設定

ユーザーはVS Code設定を通じてロギング動作を設定できます：

1. VS Code設定を開く（ファイル > 設定 > 設定）
2. 「inlined-copy」を検索
3. 以下の設定を調整する：
   - **inlined-copy.logLevel**: ログの詳細度を設定（「none」、「error」、「warn」、「info」、「debug」）
   - **inlined-copy.debugMode**: 有効にするとより詳細なメッセージがユーザーに表示される

### ベストプラクティス

- 適切なログレベルを使用する：
  - `debug`: 開発とトラブルシューティングのための詳細情報
  - `info`: 一般的な運用情報
  - `warn`: 操作を妨げない潜在的な問題
  - `error`: 正常な操作を妨げるエラー
- パフォーマンスが重要なコードパスでの過度なログ記録を避ける
- 本番環境ではパフォーマンス向上のためにログレベルを「error」または「warn」に設定する
- デバッグモードは問題のトラブルシューティング時のみ有効にする

## プロジェクト固有の知識

### VS Code API

- VS Code拡張機能をコーディングする際は、VS Code APIドキュメントを参照してください
- 公式ドキュメントはVS Code拡張機能開発の最も信頼できるソースです
- `vscode.workspace`と`vscode.window`からのAPIが頻繁に使用されます

### テスト

#### 概要とベストプラクティス

inlined-copy拡張機能は包括的なテストアプローチを使用しています：

- **モック戦略**: 基本と特化した実装を持つ階層化されたモッキング
- **テスト分離**: 各テストは適切なクリーンアップを伴う独自の環境で実行
- **共通ユーティリティ**: `src/test/vitest/mocks/`にある再利用可能なモックモジュール

##### パフォーマンステスト

パフォーマンステストはUX研究に基づく閾値を持つ段階的なスケーリング（1、10、50ファイル）を使用します：
- 1秒未満：即時と認識される
- 2秒未満：思考の流れを維持
- 5秒未満：バッチ操作の最大許容遅延

##### 新しいテストの追加

テストを追加する際：
1. `./mocks/` ディレクトリから共通のモック実装を使用する
2. 適切なクリーンアップでテスト分離を維持する
3. エッジケースカバレッジに既存のパターンに従う

#### テストフレームワークとセットアップ

- Vitestはユニットテストと統合テストのためのテストフレームワークとして使用されます
- テストは `src/test/vitest/` ディレクトリにあり、コンポーネント別に整理されています
- すべてのテストを実行するには `pnpm test` を、カバレッジレポートには `pnpm run test:coverage` を使用します
- VS Code APIとファイルシステム操作用のモック実装が提供されています

#### エッジケーステスト

拡張機能には信頼性を確保するための包括的なエッジケーステストが含まれています：

1. **特殊文字パス解決テスト**
   - スペースや特殊文字（#、$、%、!など）を含むパスの処理をテスト
   - 特殊文字を含むネストされたパスの正しい解決を検証
   - 異なるオペレーティングシステム間での一貫した動作を確保

2. **パフォーマンステスト**
   - 様々なファイルサイズ（小さいものから5MB以上）の処理時間を測定
   - 複数のファイル（10、50、100以上のファイル）でのスケーリングをテスト
   - 多くの参照を含む大きなドキュメントの効率的な処理を確保

3. **循環参照テスト**
   - 直接的な自己参照（自分自身を参照するファイル）を検出
   - 2つのファイル間の循環参照（A → B → A）を識別
   - より長い循環参照チェーン（A → B → C → A）を処理
   - 適切なエラーメッセージがユーザーに表示されることを確認

#### テストのベストプラクティス

- `helpers/testSetup.ts` から `setupStandardTestEnvironment()` を使用して標準テスト環境をセットアップする
- クリーンなテスト状態を確保するために `beforeEach` フックでモックをリセットする
- 一貫したモック実装のために `createFileExpanderMock()` などのファクトリ関数を使用する
- 異なる設定をシミュレートするために mockImplementation を使用してVSCodeEnvironmentを設定テスト用にモックする
- パラメータ処理をテストする場合、直接のVSCode依存関係なしに動作をシミュレートするヘルパー関数を作成する
- クリーンなテスト状態を確保するために beforeEach で vi.resetAllMocks() を使用する
- エッジケーステストでは、制御されたファイル構造を持つ分離されたテスト環境を作成する

### 非同期処理

- 非同期処理はPromiseベースのパターンを使用して実装されています
- 多くのVS Code APIは非同期であり、`async/await`パターンを使用して実装されています
- ファイル操作やUI表示などの非同期操作は常に適切なエラー処理を伴うPromiseチェーンを使用します

### エラー処理

- エラー処理はカスタムエラークラスを使用して実装されています
- 主なエラータイプ：`LargeDataException`、`DuplicateReferenceException`、`CircularReferenceException`、`RecursionDepthException`
- エラーは成功または失敗のステータスと追加情報を含む `FileResult` 型を使用して伝達されます
- ユーザーエクスペリエンスを向上させるために、エラーのタイプに基づいて適切なメッセージが表示されます
- エラー処理の動作は設定（例：`maxFileSize`、`maxRecursionDepth`）を通じてカスタマイズできます
- パフォーマンス最適化のために、大きなファイルはストリーミングを使用して処理され、ファイル内容はキャッシュされます

## ライセンス

MITライセンス - 詳細については[LICENSE](LICENSE)ファイルを参照してください。